# Database Migration Engine — CLAUDE.md

## Project Overview

Zero-downtime PostgreSQL schema migration CLI. Parses SQL with the real PG parser, detects dangerous DDL operations, suggests safe alternatives, executes with rollback capability.

**Status:** Phase 4 complete — database connection (pgx pool), advisory locks (LockHandle), schema_migrations tracker CRUD, integration tests (testcontainers-go). Next: Phase 5 (Execution Engine).

## Stack

Go 1.22+ | pg_query_go v6 (C-backed PG parser) | Cobra CLI | pgx v5 | testify + testcontainers-go | YAML config (gopkg.in/yaml.v3) | lipgloss TUI

## Key Commands

```bash
# CGO_ENABLED=1 is required for ALL Go commands (pg_query_go wraps C)
make audit          # Full gate: fmt + vet + lint + test + coverage (run before committing)
make test           # Unit tests with -race
make test-integration  # Integration tests (requires Docker)
make lint           # golangci-lint
make coverage-check # Fail if below 80%
```

## Architecture

```
cmd/migrate/main.go → internal/cli/ → internal/{parser,migration,analyzer,planner,executor,tracker,database}
```

- `cmd/migrate/` — Thin entry point, no business logic
- `internal/cli/` — Cobra commands, output formatting, only place that prints errors/sets exit codes
- `internal/config/` — YAML config, env var overrides, flag merging, URL redaction
- `internal/parser/` — Wraps pg_query_go Parse(), returns typed AST
- `internal/migration/` — Migration type, file loader, version sorter, checksums
- `internal/analyzer/` — Danger detection engine. Rule interface + implementations in `rules/` (one file per rule)
- `internal/planner/` — Execution plan builder, impact estimation (future)
- `internal/executor/` — Transaction mgmt, lock/statement timeouts, advisory locks (future)
- `internal/tracker/` — schema_migrations CRUD (future)
- `internal/database/` — pgx pool, advisory lock helpers (future)

## Key Design Decisions

1. **Real PostgreSQL parser** via pg_query_go — 100% accurate for valid PG SQL
2. **Rule-based analysis** — each danger rule is a standalone `Rule` interface implementation
3. **Advisory locks** — `pg_try_advisory_lock` prevents concurrent migration runs
4. **CREATE INDEX CONCURRENTLY** — detected and executed outside transaction (PG requirement)
5. **PG version-aware** — rules adjust for target PG version (e.g., non-volatile DEFAULT safe on PG 11+)
6. **CGO required** — pg_query_go wraps C library, `CGO_ENABLED=1` in all commands

## Coding Conventions

- All code in `internal/` — nothing exported outside this module
- No `utils/`, `helpers/`, `common/` packages — name packages by domain
- Return `error`, never `panic`; wrap with context: `fmt.Errorf("loading migration %s: %w", path, err)`
- Sentinel errors as package-level `var`; check with `errors.Is()` / `errors.As()`
- Interfaces in the consumer package, not the provider
- No `interface{}` / `any` unless unavoidable — use typed AST nodes from pg_query_go
- No global mutable state — pass dependencies explicitly
- Database errors must include operation context (e.g., which migration was being applied)
- Every `//nolint` must specify linter AND reason: `//nolint:funlen // table-driven test`
- Complexity limits: cyclomatic 15, cognitive 20, function length 80 lines / 40 statements

## Testing

- Table-driven tests for all pure logic (parser, analyzer rules, sorter, config)
- `t.Parallel()` on every `func Test*` AND every `t.Run` subtest
- `require.*` for preconditions (stops on failure), `assert.*` for assertions (continues)
- `t.Helper()` on all test helpers; `t.Cleanup()` instead of `defer` in helpers
- Black-box tests (`package foo_test`) for public API; white-box (`package foo`) only for unexported logic
- Naming: `TestFunctionName_scenario_expected`
- Helpers set up state only — tests make assertions

### Coverage Targets

- **90%** on `internal/analyzer/rules/` (core value)
- **85%** on `internal/executor/`
- **80%** total project, **70%** per-file floor

## Security

- All credentials via `MIGRATE_*` env vars or CLI flags — no secrets in code
- `migrate.yml` and `.env` are gitignored; only `config.example.yml` committed
- Use `config.RedactURL()` for database URLs in CLI output — never log raw URLs
- `gitleaks` on every commit via lefthook; `gosec` enabled in linter

## Git & Workflow

- Branch naming: `feat/`, `fix/`, `chore/` prefix
- Conventional commits: `feat:`, `fix:`, `test:`, `refactor:`, `chore:`, `docs:`
- **No AI attribution** — no `Co-Authored-By`, "Generated by", or AI references in any artifact
- Pre-commit hooks: gofumpt, goimports, golangci-lint, go vet, gitleaks
- Pre-push hooks: tests with race detector, coverage ≥80%

## Session Workflow

1. `/clear` → read `CLAUDE.md` → check `plans/checklist.md` for current phase
2. Read relevant phase plan from `plans/phases/`
3. Implement in small chunks, test after each
4. `make audit` before committing
5. Update `plans/checklist.md` after completing a phase step

## References

`plans/prd.md` (requirements) | `plans/implementation_plan.md` (9-phase plan) | `plans/checklist.md` (checklist) | `plans/phases/` (phase plans) | `.golangci.yml` | `.testcoverage.yml` | `.github/workflows/ci.yml`
